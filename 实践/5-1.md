```python
import torch
from torch import nn
import d2l
```

# 如果将MySequential中存储块的方式更改为Python列表，会出现什么样的问题？


```python
x=torch.ones(1,5)
# 更改前
class MySequential(nn.Module):
    def __init__(self, *args):
        super().__init__()
        for idx, module in enumerate(args):
            # 这里，module是Module子类的一个实例。我们把它保存在'Module'类的成员
            # 变量_modules中。_module的类型是OrderedDict
            self._modules[str(idx)] = module
    def forward(self, X):
        # OrderedDict保证了按照成员添加的顺序遍历它们
        for block in self._modules.values():
            X = block(X)
        return X
def init_constant(m):
    if type(m) == nn.Linear:
        nn.init.constant_(m.weight,1)
        nn.init.zeros_(m.bias)
a=MySequential(nn.Linear(5, 5), nn.ReLU(), nn.Linear(5, 5))
a.apply(init_constant)
print(a(x))
print(a.state_dict())
```

    tensor([[25., 25., 25., 25., 25.]], grad_fn=<AddmmBackward0>)
    OrderedDict([('0.weight', tensor([[1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.]])), ('0.bias', tensor([0., 0., 0., 0., 0.])), ('2.weight', tensor([[1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.]])), ('2.bias', tensor([0., 0., 0., 0., 0.]))])



```python
# 更改后
class MySequential2(nn.Module):
    def __init__(self, *args):
        super().__init__()
        self.list=[]
        for idx, module in enumerate(args):
            self.list.append(module)
    def forward(self, X):
        for block in self.list:
            X = block(X)
        return X
        
def init_constant(m):
    if type(m) == nn.Linear:
        nn.init.constant_(m.weight,1)
        nn.init.zeros_(m.bias)
a2=MySequential2(nn.Linear(5, 5), nn.ReLU(), nn.Linear(5, 5))
# 无法使用自带的apply初始化参数了
a2.apply(init_constant)
print(a2(x))
# 需要这样初始化，或者重写apply
for i in a2.list:
    init_constant(i)
print(a2(x))
# state_dict() 失效了
print(a2.state_dict())
```

    tensor([[ 0.4897, -0.3354, -0.1935,  0.4090, -0.2873]],
           grad_fn=<AddmmBackward0>)
    tensor([[25., 25., 25., 25., 25.]], grad_fn=<AddmmBackward0>)
    OrderedDict()


# 实现一个块，它以两个块为参数，例如net1和net2，并返回前向传播中两个网络的串联输出。这也被称为平行块。


```python
class ParallelSequential(nn.Module):
    def __init__(self,*args):
        super().__init__()
        for idx,module in enumerate(args):
            self._modules[str(idx)]=module
    def forward(self, X):
        return torch.cat((self._modules['0'](X),self._modules['1'](X)),dim=0)
net1=MySequential(nn.Linear(5,5), nn.ReLU(), nn.Linear(5,5))
net2=MySequential(nn.Linear(5,5), nn.ReLU(), nn.Linear(5,5))
a3=ParallelSequential(net1,net2)
a3.apply(init_constant)
a3(x)
```




    tensor([[25., 25., 25., 25., 25.],
            [25., 25., 25., 25., 25.]], grad_fn=<CatBackward0>)



# 假设我们想要连接同一网络的多个实例。实现一个函数，该函数生成同一个块的多个实例，并在此基础上构建更大的网络。


```python
# 不知道这个问题是什么意思
```
